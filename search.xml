<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Cloud Gateway踩坑记录之路由动态配置的实现]]></title>
    <url>%2F2019%2F07%2F04%2FSpring-Cloud-Gateway%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[初心​ 前阵子在项目中应用了spring-cloud-gateway作为微服务网关，由于spring-cloud-gateway基于webfux，而本人是首次尝试使用webflux，因此踩到了很多坑，特此记录下来，希望能够帮助和我一样初次使用spring-cloud-gateway的同学尽量少踩几个坑。 问题现象关于spring-cloud-gateway的路由配置，官方文档里的demo都是通过配置文件来手动配置路由，这样每次修改路由配置都需要重启网关服务，而实际使用时网关作为总入口不能频繁重启，因此需要实现无重启的方式来热更新路由配置。虽然基于服务id的路由发现可以通过配置实现自动路由（具体配置方式如下图所示），但是静态路由只能手动一个个配置。当然也可以配置服务总线实现配置文件热更新，这样修改git里的配置文件就能自动更新路由而无需重启，但是这样必须操作git，无法集成在自己的app里，而网关自带的post接口虽然可以动态修改路由，但是无法持久化，各种现有的动态路由实现方式和存在问题如下表所示。123456789101112131415161718#基于服务发现自动路由，如果启用基于服务发现的那些路由可以不用配置路由了spring: cloud: gateway: discovery: locator: # 将服务id的路由转成全小写，默认是全大写 lower-case-service-id: true # 启用服务发现自动路由 enabled: true filters: #不省略头部避免跳转到页面时css和js等静态资源加载不到的问题 - StripPrefix=0 # 限流过滤器 - name: RequestRateLimiter args: redis-rate-limiter.replenishRate: 10 redis-rate-limiter.burstCapacity: 20 配置方式 动态路由不需要重启 静态路由不需要重启 配置可持久化 修改配置的操作是否可集成到其他app 配置文件或者RouteLocator类 × × √ × 在配置文件里设置自动路由 √ × √ × 通过消息总线实现配置文件更新时网关自动热更新 √ √ √ × 通过spring cloud gateway自带的修改路由接口进行修改 √ √ × √ 探索​ 由于上诉这些方法都存在一定的问题，这里就不详细描述他们的实现方式了。这里主要描述如何实现能够满足上述四个要求的路由动态配置方法。（不关心原理的可跳过这一节直接阅读解决方法） ​ 通过查看spring cloud gateway 的源码我们可以发现，网关的路由配置接口为RouteDefinitionLocator类，该类只有一个方法getRouteDefinitions()用于获取定义好的路由配置。其代码如下图所示。 1234567891011package org.springframework.cloud.gateway.route;import reactor.core.publisher.Flux;/** * @author Spencer Gibb */public interface RouteDefinitionLocator &#123; Flux&lt;RouteDefinition&gt; getRouteDefinitions();&#125; ​ 该类的具体实现及相应作用如下表所示。 实现类类名 CachingRouteDefinitionLocator 缓存包装类，将网关路由的配置通过一个map缓存到内存里 PropertiesRouteDefinitionLocator 从配置文件读取路由配置 DiscoveryClientRouteDefinitionLocator 从注册中心读取路由配置 RouteDefinitionRepository 接口，从库（比如内存、redis等）读取路由配置 CompositeRouteDefinitionLocator 组合类，将各个路由配置通过flatMap整合起来 ​ 路由的配置有这么多类的实现，那么实际起作用的是哪几个类呢，这个可以从autoconfig的类里面查看。我们从GatewayDiscoveryClientAutoConfiguration类和GatewayAutoConfiguration类里可以看到路由类的配置，如下代码所示。 12345678910111213141516171819// GatewayDiscoveryClientAutoConfiguration类源码中关于路由配置的部分public class GatewayDiscoveryClientAutoConfiguration &#123; @Bean @ConditionalOnBean(DiscoveryClient.class) @ConditionalOnProperty(name = "spring.cloud.gateway.discovery.locator.enabled") public DiscoveryClientRouteDefinitionLocator discoveryClientRouteDefinitionLocator( DiscoveryClient discoveryClient, DiscoveryLocatorProperties properties) &#123; return new DiscoveryClientRouteDefinitionLocator(discoveryClient, properties); &#125; @Bean public DiscoveryLocatorProperties discoveryLocatorProperties() &#123; DiscoveryLocatorProperties properties = new DiscoveryLocatorProperties(); properties.setPredicates(initPredicates()); properties.setFilters(initFilters()); return properties; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445// GatewayAutoConfiguration类源码中关于路由配置的部分public class GatewayAutoConfiguration &#123; @Bean @ConditionalOnMissingBean public PropertiesRouteDefinitionLocator propertiesRouteDefinitionLocator(GatewayProperties properties) &#123; return new PropertiesRouteDefinitionLocator(properties); &#125; @Bean @ConditionalOnMissingBean(RouteDefinitionRepository.class) public InMemoryRouteDefinitionRepository inMemoryRouteDefinitionRepository() &#123; return new InMemoryRouteDefinitionRepository(); &#125; @Bean @Primary public RouteDefinitionLocator routeDefinitionLocator (List&lt;RouteDefinitionLocator&gt; routeDefinitionLocators) &#123; return new CompositeRouteDefinitionLocator( Flux.fromIterable(routeDefinitionLocators)); &#125; @Bean public RouteLocator routeDefinitionRouteLocator( GatewayProperties properties, List&lt;GatewayFilterFactory&gt; GatewayFilters, List&lt;RoutePredicateFactory&gt; predicates, RouteDefinitionLocator routeDefinitionLocator, @Qualifier("webFluxConversionService") ConversionService conversionService) &#123; return new RouteDefinitionRouteLocator( routeDefinitionLocator, predicates, GatewayFilters, properties, conversionService); &#125; @Bean @Primary //TODO: property to disable composite? public RouteLocator cachedCompositeRouteLocator(List&lt;RouteLocator&gt; routeLocators) &#123; return new CachingRouteLocator( new CompositeRouteLocator( Flux.fromIterable(routeLocators))); &#125;&#125; ​ 从上述源码中我们可以看到，当spring.cloud.gateway.discovery.locator.enabled属性设置为true时，启用DiscoveryClientRouteDefinitionLocator自动发现路由，此外还默认开启了PropertiesRouteDefinitionLocator和InMemoryRouteDefinitionRepository（RouteDefinitionRepository接口的默认实现）路由配置类，并通过CompositeRouteDefinitionLocator将这些路由配置合并起来，然后通过CachingRouteDefinitionLocator类缓存起来。 解决​ 从源码中我们看到，InMemoryRouteDefinitionRepository实现类Bean的配置的注解@ConditionalOnMissingBean(RouteDefinitionRepository.class),也就是说如果我们自行实现RouteDefinitionRepository类并配置这个Bean，那么就能在我们自行实现的类里定义路由然后由CompositeRouteDefinitionLocator帮我们合并到总体的路由配置里，由于RouteDefinitionRepository的定义就是通过库去获取配置，所以我们可以实现该接口，然后在getRouteDefinitions()方法里读取库里的信息——这里使用redis，这样我们只要在其他应用里直接操作redis缓存就能实现路由的更新，无需重启网关。具体实现类如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115@Componentpublic class DynamicRouterRepository implements RouteDefinitionRepository&#123; @Autowired private RedisTemplate redisTemplate; @Override public Flux&lt;RouteDefinition&gt; getRouteDefinitions() &#123; try &#123; //从redis读取路由配置，redis里的信息可使用其他应用进行操作 Object obj = redisTemplate.opsForValue().get("CLOUD_GATEWAY_ROUTE_KEY"); if (obj == null) &#123; return Flux.empty(); &#125; //CustomRouteConfig是自定义的路由配置信息类 List&lt;CustomRouteConfig&gt; results = (List&lt;CustomRouteConfig&gt;) obj; List&lt;RouteDefinition&gt; routeDefinitions=new ArrayList&lt;&gt;(); //遍历配置信息列表，将其转化为标准的路由配置定义 for(CustomRouteConfig customRouteConfig:results)&#123; //只对启用的且有服务id的路由配置进行标准化 if(!StringUtils.isEmpty(customRouteConfig.getPath()) &amp;&amp;"1".equals(customRouteConfig.getEnabled()))&#123; RouteDefinition definition = new RouteDefinition(); List&lt;PredicateDefinition&gt; predicateDefinitions =new ArrayList&lt;&gt;(); List&lt;FilterDefinition&gt; filterDefinitions=new ArrayList&lt;&gt;(); //不存在跳转url，视为动态路由 if(StringUtils.isEmpty(customRouteConfig.getUrl()))&#123; definition.setUri( new URI("lb://"+customRouteConfig.getServiceId() .toUpperCase())); &#125; //不存在跳转url但有服务id,视为静态路由 else if(!StringUtils.isEmpty(customRouteConfig.getServiceId()))&#123; definition.setUri(new URI(customRouteConfig.getUrl())); //重定向过滤器 FilterDefinition redirect=new FilterDefinition(); redirect.setName("RedirectTo"); Map&lt;String,String&gt; redirectArgs=new HashMap&lt;&gt;(); redirectArgs.put("status","302"); redirectArgs.put("url",sysZuulRoute.getUrl()); redirect.setArgs(redirectArgs); filterDefinitions.add(redirect); &#125; //两者同时不存在,跳过这个路由 else&#123; continue; &#125; PredicateDefinition predicateDefinition= new PredicateDefinition(); predicateDefinition.setName("Path"); Map&lt;String,String&gt; args=new HashMap&lt;&gt;(); //路由的匹配路径 args.put("pattern",customRouteConfig.getPath()); predicateDefinition.setArgs(args); predicateDefinitions.add(predicateDefinition); //前缀过滤器，过滤器的名称和官方文档里配置文件里的名称一致，参数可能不一致，需 //要查看该过滤器的Config类确定 FilterDefinition filterDefinition=new FilterDefinition(); filterDefinition.setName("StripPrefix"); Map&lt;String,String&gt; stripArgs=new HashMap&lt;&gt;(); stripArgs.put("parts",customRouteConfig.getStripPrefix()); filterDefinition.setArgs(stripArgs); filterDefinitions.add(filterDefinition); //限流过滤器，仅测试动态路由时可去掉这一段 FilterDefinition rateLimit=new FilterDefinition(); rateLimit.setName("RequestRateLimiter"); Map&lt;String,String&gt; rateLimitArgs=new HashMap&lt;&gt;(); rateLimitArgs.put("redis-rate-limiter.replenishRate","100"); rateLimitArgs.put("redis-rate-limiter.burstCapacity","200"); //这里customKeyResolver是自定义限流解析器 rateLimitArgs.put("key-resolver", "#&#123;@customKeyResolver&#125;"); rateLimit.setArgs(rateLimitArgs); filterDefinitions.add(rateLimit); definition.setFilters(filterDefinitions); definition.setId(customRouteConfig.getId().toString()); definition.setPredicates(predicateDefinitions); definition.setPredicates(predicateDefinitions); routeDefinitions.add(definition); &#125; &#125; return Flux.fromIterable(routeDefinitions); &#125; catch (Exception e) &#123; e.printStackTrace(); return Flux.empty(); &#125; &#125; //因为网关的配置是采用其他微服务修改redis缓存实现的，而不是通过gateway的rest api修改的， //因此无需实现save和delete方法 @Override public Mono&lt;Void&gt; save(Mono&lt;RouteDefinition&gt; mono) &#123; return mono.flatMap(r -&gt; &#123; try &#123; return Mono.empty(); &#125; catch (Exception e) &#123; e.printStackTrace(); return Mono.defer(() -&gt; Mono.error(new NotFoundException("RouteDefinition save error: "+ r.getId()))); &#125; &#125;); &#125; @Override public Mono&lt;Void&gt; delete(Mono&lt;String&gt; mono) &#123; return null; &#125;&#125; 自定义的路由信息类如下，仅供参考，可自行实现 123456789101112131415161718192021222324252627public class SysZuulRoute implements Serializable &#123; /** * 路由匹配路径 */ private String path; /** * 服务id */ private String serviceId; /** * 静态路由转发地址 */ private String url; /** * 转发去掉前缀 */ private String stripPrefix; /** * 是否启用 */ private String enabled; &#125; 这样就能实现路由的动态配置了。 备注本人使用的spring cloud gateway版本为2.1.0.RC3，其他版本可能会有细微区别]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>spring cloud gateway</tag>
        <tag>后台</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一个博客]]></title>
    <url>%2F2019%2F07%2F03%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[123function sayHello()&#123; console.lgo("hello world");&#125;]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
