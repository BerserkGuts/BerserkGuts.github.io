<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IDEA自动生成注释]]></title>
    <url>%2F2019%2F08%2F02%2FIDEA%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[目的​ 最近公司要求对类和方法进行标准化的注释，一方面每次都手动输入规定格式的注释繁琐又低效，另一方面每次还得记住公司规范的格式，生怕格式不统一挨批 &gt;_&lt; 。所幸IDEA提供了灵活的注释自动生成方法，解决了我的问题，现在总结后分享给大家。 类注释的自动生成​ 类注释的生成相对简单。IDEA本身就自带了类生成时的自动注释，会自动生成日期和计算机名，我们要做到的就是修改自动生成模板，并将日期替换成指定格式，计算机名替换成真实姓名即可。选择File(文件)-&gt;settings…(设置)，进入设置界面，选择Editor（编辑器）下的File and CodeTemplates,在右边上方的tab页选择includs，再在下方选择FileHeader，这是默认的类文件头，将这个文件头的内容替换为如下代码，如下图所示(注意记得替换你自己的真实姓名或昵称。如果想修改日期格式可以将“yyyy-MM-dd HH:mm:ss”替换为你要的格式)。 12345678910111213#set($str = &quot;&quot;)#set($stringClass=$str.getClass())#set($localeClass=$stringClass.forName(&quot;java.util.Locale&quot;))#set($date=$stringClass.forName(&quot;java.util.Date&quot;).newInstance())#set($locale=$localeClass.getConstructor($stringClass).newInstance(&quot;en_US&quot;))#set($dateFormat=$stringClass.forName(&quot;java.text.SimpleDateFormat&quot;).getConstructor($stringClass, $localeClass).newInstance(&quot;yyyy-MM-dd HH:mm:ss&quot;, $locale))#set($fdate=$dateFormat.format($date))/** * @替换成你的真实姓名 * @$&#123;fdate&#125; */ 设置完毕后点击Apply应用变更并点击OK关闭设置窗口。然后新建一Class文件，就会自动生成类注释了，如下图所示。 方法注释的自动生成​ 方法注释的生成相对复杂一些，因为要自动收集参数名。IDEA默认的方法注释可以在方法上面输入/**然后按回车键就会生成默认的方法注释，默认的方法注释包含了参数列表和返回值，如果你的方法注释只需要这两项内容则可以使用默认模板，可以跳过下文。如果想要实现自定义的方法注释模板则请继续看下文内容。 ​ 同上面的步骤打开settings，选择Editor-&gt;LiveTemplates,然后点击右侧的“+”按钮，在弹出添加选项中选择TemplateGroup，弹出对话框，输入自定义模板组的名称，完成创建。如下图所示。 自定义模板组创建完毕后，选中刚创建的模板组，点击右侧的“+”按钮，这次选择LiveTemplate，创建模板。如下图所示。 模板创建完毕后，选择这个模板，修改快捷键（建议设置为*号）、说明、脚本，如下图所示。脚本代码如下。 12345678** * 一句话功能简述 * 功能详细描述 * $VAR1$ $params$* @return $returns$ 返回参数说明 * @author 徐凯 * @exception/throws 违例类型 违例说明 */ 接下来编辑变量。点击右侧Edit Variables按钮，出现变量编辑按钮，如下图所示。在VAR1的expression输入脚本，代码如下所示，在returns输入methodReturnType() 获取返回值类型（如无需获取则可以不填），设置完毕后点击ok即可。如下图所示。 12345678groovyScript(" def result=''; def params=\"$&#123;_1&#125;\".replaceAll('[\\\\[|\\\\]|\\\\s]', '').split(',').toList(); for(i = 0; i &lt; params.size(); i++) &#123; if(i!=0)result+= ' * '; result+='@param ' + params[i] +' 参数说明'+ ((i &lt; (params.size() - 1)) ? '\\n': ''); &#125;; return result", methodParameters()) 最后，设置模板的生效范围。点击下方的Define按钮，在弹出的作用范围列表里选择JAVA即可。如下图所示。 设置完毕后点击apply和ok退出setting界面。现在可以使用方法自动生成了，在方法体的上方输入/*,然后按Tab键，就会自动生成方法的注释。如下图所示。]]></content>
      <tags>
        <tag>IDEA</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud Demo搭建教程]]></title>
    <url>%2F2019%2F07%2F26%2FSpringCloud-Demo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向对象​ spring cloud初学者 目标——麻雀虽小五脏俱全​ 本demo将搭建最小化、但又完整的spring cloud技术体系，方便加深初学者对spring cloud的理解。文中部分源码不是最优方案，工程实践请自行优化。 准备 jdk（1.8及以上） maven（3.3及以上，低版本maven与spring boot不兼容，必须升级） 可用git仓库（gitlab或者github等） 互联网 Intellij Idea（或其他ide） 注册中心Eureka的搭建​ 创建一个总的maven工程。maven工程创建完毕以后，修改pom文件，添加所有组件都需要用到的公共包。具体如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!--项目基础属性不要修改，保留自动生成时候的内容--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.xukai.cloud&lt;/groupId&gt; &lt;artifactId&gt;springDemo&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--依赖版本管理，所有子模块的依赖版本号都在这里统一管理--&gt; &lt;properties&gt; &lt;!--spring boot 和cloud版本，两者有依赖关系，请同时修改--&gt; &lt;spring-boot.version&gt;2.1.1.RELEASE&lt;/spring-boot.version&gt; &lt;spring-cloud.version&gt;Greenwich.RC2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 使用aliyun镜像 --&gt; &lt;repositories&gt; &lt;!--阿里云镜像站，一般的依赖从这里下载--&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/repository&gt; &lt;!--springboot的依赖从这里下载--&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; //todo 接下来创建一模块，名称为eureka（也可以为其他名称）。待模块创建后在该模块的pom.xml(注意不是总的工程的pom.xml)中添加依赖，并设置打包规则。如下所示。 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;springDemo&lt;/artifactId&gt; &lt;groupId&gt;org.xukai.cloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.xukai.cloud&lt;/groupId&gt; &lt;artifactId&gt;eureka&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; resource文件夹下新建springboot的配置文件，名称为bootstrap.yml,内容如下 123456789101112131415161718192021222324252627server: port: 3001spring: application: name: eureka-server cloud: config: enabled: false security: basic: enabled: true # 启用身份认证 user: name: admin # 定义用户名 password: hello # 定义密码eureka: client: fetch-registry: false register-with-eureka: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ instance: hostname: eurekaserver server: enable-self-preservation: false eviction-interval-timer-in-ms: 5000 新建springboot启动类，如下所示 123456789@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 新建spring security配置，关闭csrf功能，避免客户端注册不上 123456789@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //关闭crsf拦截器避免微服务注册不上 http.csrf().disable(); &#125;&#125; 启动模块，访问http://localhost:3001，出现eureka的界面及说明eureka服务创建成功。如下图所示。 配置中心spring cloud config的搭建​ 在git库新建一个新的项目，clone这个库，并在这个项目创建一个文件夹，名为config-file(任意名称即可)，在创建一个配置文件，名称为application-dev.yml(名称必须一致)，该配置文件中的配置会对所有注册到注册中心并且激活的profile为dev的应用生效，具体配置内容如下： 123custom: testValue: foo testValue2: bar ​ 修改完毕后push到远程git库。 ​ 在刚才的工程中再新建一个模块，名称为config。修改该模块的pom文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;springDemo&lt;/artifactId&gt; &lt;groupId&gt;org.xukai.cloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.xukai.cloud&lt;/groupId&gt; &lt;artifactId&gt;config&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--配置中心服务--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--注册中心客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 在resource下新建springboot的配置文件，内容如下： 12345678910111213141516171819202122232425262728293031323334353637server: port: 3002spring: application: name: config-server profiles: #本地化配置的激活profile必须为native，不然会报错 active: dev cloud: config: server: #将配置文件本地化，不建议这么做# native:# search-locations: classpath:conf/# 通过git来管理配置文件，推荐 git: uri: [xxxxx.git,实际值为你的配置文件所在的git仓库地址] default-label: $&#123;spring.profiles.active&#125; searchPaths: [值为你的配置文件git库的文件夹名称] username: [git仓库用户名] password: [git仓库密码]---spring: profiles: deveureka: instance: prefer-ip-address: true lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 20 client: register-with-eureka: true serviceUrl: #这里localhost需要修改为实际的eureka地址,admin为eureka的用户名，hello为eureka密码 defaultZone: http://admin:hello@localhost:3001/eureka registry-fetch-interval-seconds: 10 新建一启动类，内容如下： 123456789@EnableDiscoveryClient@EnableConfigServer@SpringBootApplicationpublic class ConfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigApplication.class, args); &#125;&#125; 启动服务(已经启动了eureka)，浏览器访问http://localhost:3002/application/dev返回git里的配置内容的json数据，就说明配置中心搭建成功。 网关搭建新建一项目，名为gateway。pom添加依赖如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;springDemo&lt;/artifactId&gt; &lt;groupId&gt;org.xukai.cloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.xukai.cloud&lt;/groupId&gt; &lt;artifactId&gt;gateway&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--注册中心客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 新建配置文件，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647server: port: 3099spring: application: name: cloud-gateway profiles: active: dev cloud: config: fail-fast: true discovery: service-id: config-server enabled: true profile: $&#123;spring.profiles.active&#125; label: dev # 基于服务发现自动匹配路由，如果启用基于服务发现的那些路由可以不用配置路由了 gateway: routes: - predicates: - Path=/baidu/** filters: - StripPrefix=1 uri: "https://www.baidu.com" discovery: locator: # 小写 lower-case-service-id: true enabled: true filters: # 省略头部避免跳转到页面时css和js等静态资源加载不到的问题 - StripPrefix=0---spring: profiles: dev security: basic: enable: falseeureka: instance: prefer-ip-address: true lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 20 client: serviceUrl: defaultZone: http://admin:hello@localhost:3001/eureka registry-fetch-interval-seconds: 10 新建启动类，内容如下： 12345678@SpringBootApplication@EnableDiscoveryClientpublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 启动，浏览器访问http://localhost:3099/baidu 进入百度首页，说明网关代理成功。 客户端搭建新建一模块，名称为client，pom添加依赖如下 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;springDemo&lt;/artifactId&gt; &lt;groupId&gt;org.xukai.cloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.xukai.cloud&lt;/groupId&gt; &lt;artifactId&gt;client&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--注册中心客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 新建配置文件，内容如下 123456789101112131415161718192021222324252627282930313233server: port: 8001 servlet: context-path: /demo-clientspring: application: name: demo-client profiles: active: dev cloud: config: fail-fast: true discovery: service-id: config-server enabled: true profile: $&#123;spring.profiles.active&#125; label: dev---spring: profiles: dev security: basic: enable: falseeureka: instance: prefer-ip-address: true lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 20 client: serviceUrl: defaultZone: http://admin:hello@localhost:3001/eureka registry-fetch-interval-seconds: 10 新建启动类和controller，内容如下 1234567@SpringBootApplication@EnableDiscoveryClientpublic class ClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ClientApplication.class, args); &#125;&#125; 12345678910@Controller@RequestMapping("demo")public class DemoController &#123; @GetMapping("say") @ResponseBody public String sayHello()&#123; return "Hello world!"; &#125;&#125; 访问http://localhost:8001/demo-client/demo/say返回数据说明客户端启动成功，访问http://localhost:3099/demo-client/demo/say返回数据说明该客户端已被网关自动代理。 上面步骤完成后，eureka的页面中应该已经注册了3个服务，如下图所示。 至此，基本功能已经搭建完毕!!稍事休息，接下来来尝试下稍微高级点的功能！ 负载均衡配置及测试 ​ 自动发现的路由已经默认做了负载均衡，可以同时运行两个客户端（注意修改下端口），然后稍微修改下接口使两个服务返回的数据不一样，这样就能识别具体请求的那个服务，然后通过网关多次访问这个接口，如果返回的内容不一样说明负载均衡生效了。 限流配置及测试 ​ 限流需要添加限流过滤器，在gateway网关的配置文件里添加过滤器的配置，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455server: port: 3099spring: application: name: cloud-gateway profiles: active: dev cloud: config: fail-fast: true discovery: service-id: config-server enabled: true profile: $&#123;spring.profiles.active&#125; label: dev # 基于服务发现自动匹配路由，如果启用基于服务发现的那些路由可以不用配置路由了 gateway: routes: - predicates: - Path=/baidu/** filters: - StripPrefix=1 uri: "https://www.baidu.com" discovery: locator: # 小写 lower-case-service-id: true enabled: true filters: # 省略头部避免跳转到页面时css和js等静态资源加载不到的问题 - StripPrefix=0 # 限流过滤器，基于令牌桶算法实现 - name: RequestRateLimiter args: # 令牌生成速率 redis-rate-limiter.replenishRate: 10 # 令牌桶最大容量 redis-rate-limiter.burstCapacity: 20---spring: profiles: dev security: basic: enable: falseeureka: instance: prefer-ip-address: true lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 20 client: serviceUrl: defaultZone: http://admin:hello@localhost:3001/eureka registry-fetch-interval-seconds: 10 然后通过并发测试工具（如postman等）进行并发测试，使同一个接口的每秒调用数超过20，如果返回429则说明限流起作用了。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>后台</tag>
        <tag>微服务</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Gateway踩坑记录之路由动态配置的实现]]></title>
    <url>%2F2019%2F07%2F04%2FSpring-Cloud-Gateway%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[初心​ 前阵子在项目中应用了spring-cloud-gateway作为微服务网关，由于spring-cloud-gateway基于webfux，而本人是首次尝试使用webflux，因此踩到了很多坑，特此记录下来，希望能够帮助和我一样初次使用spring-cloud-gateway的同学尽量少踩几个坑。 问题现象关于spring-cloud-gateway的路由配置，官方文档里的demo都是通过配置文件来手动配置路由，这样每次修改路由配置都需要重启网关服务，而实际使用时网关作为总入口不能频繁重启，因此需要实现无重启的方式来热更新路由配置。虽然基于服务id的路由发现可以通过配置实现自动路由（具体配置方式如下图所示），但是静态路由只能手动一个个配置。当然也可以配置服务总线实现配置文件热更新，这样修改git里的配置文件就能自动更新路由而无需重启，但是这样必须操作git，无法集成在自己的app里，而网关自带的post接口虽然可以动态修改路由，但是无法持久化，各种现有的动态路由实现方式和存在问题如下表所示。yml配置： 123456789101112131415161718#基于服务发现自动路由，如果启用基于服务发现的那些路由可以不用配置路由了spring: cloud: gateway: discovery: locator: # 将服务id的路由转成全小写，默认是全大写 lower-case-service-id: true # 启用服务发现自动路由 enabled: true filters: #不省略头部避免跳转到页面时css和js等静态资源加载不到的问题 - StripPrefix=0 # 限流过滤器 - name: RequestRateLimiter args: redis-rate-limiter.replenishRate: 10 redis-rate-limiter.burstCapacity: 20 配置方式 动态路由不需要重启 静态路由不需要重启 配置可持久化 修改配置的操作是否可集成到其他app 配置文件或者RouteLocator类 × × √ × 在配置文件里设置自动路由 √ × √ × 通过消息总线实现配置文件更新时网关自动热更新 √ √ √ × 通过spring cloud gateway自带的修改路由接口进行修改 √ √ × √ 探索​ 由于上诉这些方法都存在一定的问题，这里就不详细描述他们的实现方式了。这里主要描述如何实现能够满足上述四个要求的路由动态配置方法。（不关心原理的可跳过这一节直接阅读解决方法） ​ 通过查看spring cloud gateway 的源码我们可以发现，网关的路由配置接口为RouteDefinitionLocator类，该类只有一个方法getRouteDefinitions()用于获取定义好的路由配置。其代码如下图所示。 1234567891011package org.springframework.cloud.gateway.route;import reactor.core.publisher.Flux;/** * @author Spencer Gibb */public interface RouteDefinitionLocator &#123; Flux&lt;RouteDefinition&gt; getRouteDefinitions();&#125; ​ 该类的具体实现及相应作用如下表所示。 实现类类名 CachingRouteDefinitionLocator 缓存包装类，将网关路由的配置通过一个map缓存到内存里 PropertiesRouteDefinitionLocator 从配置文件读取路由配置 DiscoveryClientRouteDefinitionLocator 从注册中心读取路由配置 RouteDefinitionRepository 接口，从库（比如内存、redis等）读取路由配置 CompositeRouteDefinitionLocator 组合类，将各个路由配置通过flatMap整合起来 ​ 路由的配置有这么多类的实现，那么实际起作用的是哪几个类呢，这个可以从autoconfig的类里面查看。我们从GatewayDiscoveryClientAutoConfiguration类和GatewayAutoConfiguration类里可以看到路由类的配置，如下代码所示。 12345678910111213141516171819// GatewayDiscoveryClientAutoConfiguration类源码中关于路由配置的部分public class GatewayDiscoveryClientAutoConfiguration &#123; @Bean @ConditionalOnBean(DiscoveryClient.class) @ConditionalOnProperty(name = "spring.cloud.gateway.discovery.locator.enabled") public DiscoveryClientRouteDefinitionLocator discoveryClientRouteDefinitionLocator( DiscoveryClient discoveryClient, DiscoveryLocatorProperties properties) &#123; return new DiscoveryClientRouteDefinitionLocator(discoveryClient, properties); &#125; @Bean public DiscoveryLocatorProperties discoveryLocatorProperties() &#123; DiscoveryLocatorProperties properties = new DiscoveryLocatorProperties(); properties.setPredicates(initPredicates()); properties.setFilters(initFilters()); return properties; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445// GatewayAutoConfiguration类源码中关于路由配置的部分public class GatewayAutoConfiguration &#123; @Bean @ConditionalOnMissingBean public PropertiesRouteDefinitionLocator propertiesRouteDefinitionLocator(GatewayProperties properties) &#123; return new PropertiesRouteDefinitionLocator(properties); &#125; @Bean @ConditionalOnMissingBean(RouteDefinitionRepository.class) public InMemoryRouteDefinitionRepository inMemoryRouteDefinitionRepository() &#123; return new InMemoryRouteDefinitionRepository(); &#125; @Bean @Primary public RouteDefinitionLocator routeDefinitionLocator (List&lt;RouteDefinitionLocator&gt; routeDefinitionLocators) &#123; return new CompositeRouteDefinitionLocator( Flux.fromIterable(routeDefinitionLocators)); &#125; @Bean public RouteLocator routeDefinitionRouteLocator( GatewayProperties properties, List&lt;GatewayFilterFactory&gt; GatewayFilters, List&lt;RoutePredicateFactory&gt; predicates, RouteDefinitionLocator routeDefinitionLocator, @Qualifier("webFluxConversionService") ConversionService conversionService) &#123; return new RouteDefinitionRouteLocator( routeDefinitionLocator, predicates, GatewayFilters, properties, conversionService); &#125; @Bean @Primary //TODO: property to disable composite? public RouteLocator cachedCompositeRouteLocator(List&lt;RouteLocator&gt; routeLocators) &#123; return new CachingRouteLocator( new CompositeRouteLocator( Flux.fromIterable(routeLocators))); &#125;&#125; ​ 从上述源码中我们可以看到，当spring.cloud.gateway.discovery.locator.enabled属性设置为true时，启用DiscoveryClientRouteDefinitionLocator自动发现路由，此外还默认开启了PropertiesRouteDefinitionLocator和InMemoryRouteDefinitionRepository（RouteDefinitionRepository接口的默认实现）路由配置类，并通过CompositeRouteDefinitionLocator将这些路由配置合并起来，然后通过CachingRouteDefinitionLocator类缓存起来。 解决​ 从源码中我们看到，InMemoryRouteDefinitionRepository实现类Bean的配置的注解@ConditionalOnMissingBean(RouteDefinitionRepository.class),也就是说如果我们自行实现RouteDefinitionRepository类并配置这个Bean，那么就能在我们自行实现的类里定义路由然后由CompositeRouteDefinitionLocator帮我们合并到总体的路由配置里，由于RouteDefinitionRepository的定义就是通过库去获取配置，所以我们可以实现该接口，然后在getRouteDefinitions()方法里读取库里的信息——这里使用redis，这样我们只要在其他应用里直接操作redis缓存就能实现路由的更新，无需重启网关。具体实现类如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115@Componentpublic class DynamicRouterRepository implements RouteDefinitionRepository&#123; @Autowired private RedisTemplate redisTemplate; @Override public Flux&lt;RouteDefinition&gt; getRouteDefinitions() &#123; try &#123; //从redis读取路由配置，redis里的信息可使用其他应用进行操作 Object obj = redisTemplate.opsForValue().get("CLOUD_GATEWAY_ROUTE_KEY"); if (obj == null) &#123; return Flux.empty(); &#125; //CustomRouteConfig是自定义的路由配置信息类 List&lt;CustomRouteConfig&gt; results = (List&lt;CustomRouteConfig&gt;) obj; List&lt;RouteDefinition&gt; routeDefinitions=new ArrayList&lt;&gt;(); //遍历配置信息列表，将其转化为标准的路由配置定义 for(CustomRouteConfig customRouteConfig:results)&#123; //只对启用的且有服务id的路由配置进行标准化 if(!StringUtils.isEmpty(customRouteConfig.getPath()) &amp;&amp;"1".equals(customRouteConfig.getEnabled()))&#123; RouteDefinition definition = new RouteDefinition(); List&lt;PredicateDefinition&gt; predicateDefinitions =new ArrayList&lt;&gt;(); List&lt;FilterDefinition&gt; filterDefinitions=new ArrayList&lt;&gt;(); //不存在跳转url，视为动态路由 if(StringUtils.isEmpty(customRouteConfig.getUrl()))&#123; definition.setUri( new URI("lb://"+customRouteConfig.getServiceId() .toUpperCase())); &#125; //不存在跳转url但有服务id,视为静态路由 else if(!StringUtils.isEmpty(customRouteConfig.getServiceId()))&#123; definition.setUri(new URI(customRouteConfig.getUrl())); //重定向过滤器 FilterDefinition redirect=new FilterDefinition(); redirect.setName("RedirectTo"); Map&lt;String,String&gt; redirectArgs=new HashMap&lt;&gt;(); redirectArgs.put("status","302"); redirectArgs.put("url",sysZuulRoute.getUrl()); redirect.setArgs(redirectArgs); filterDefinitions.add(redirect); &#125; //两者同时不存在,跳过这个路由 else&#123; continue; &#125; PredicateDefinition predicateDefinition= new PredicateDefinition(); predicateDefinition.setName("Path"); Map&lt;String,String&gt; args=new HashMap&lt;&gt;(); //路由的匹配路径 args.put("pattern",customRouteConfig.getPath()); predicateDefinition.setArgs(args); predicateDefinitions.add(predicateDefinition); //前缀过滤器，过滤器的名称和官方文档里配置文件里的名称一致，参数可能不一致，需 //要查看该过滤器的Config类确定 FilterDefinition filterDefinition=new FilterDefinition(); filterDefinition.setName("StripPrefix"); Map&lt;String,String&gt; stripArgs=new HashMap&lt;&gt;(); stripArgs.put("parts",customRouteConfig.getStripPrefix()); filterDefinition.setArgs(stripArgs); filterDefinitions.add(filterDefinition); //限流过滤器，仅测试动态路由时可去掉这一段 FilterDefinition rateLimit=new FilterDefinition(); rateLimit.setName("RequestRateLimiter"); Map&lt;String,String&gt; rateLimitArgs=new HashMap&lt;&gt;(); rateLimitArgs.put("redis-rate-limiter.replenishRate","100"); rateLimitArgs.put("redis-rate-limiter.burstCapacity","200"); //这里customKeyResolver是自定义限流解析器 rateLimitArgs.put("key-resolver", "#&#123;@customKeyResolver&#125;"); rateLimit.setArgs(rateLimitArgs); filterDefinitions.add(rateLimit); definition.setFilters(filterDefinitions); definition.setId(customRouteConfig.getId().toString()); definition.setPredicates(predicateDefinitions); definition.setPredicates(predicateDefinitions); routeDefinitions.add(definition); &#125; &#125; return Flux.fromIterable(routeDefinitions); &#125; catch (Exception e) &#123; e.printStackTrace(); return Flux.empty(); &#125; &#125; //因为网关的配置是采用其他微服务修改redis缓存实现的，而不是通过gateway的rest api修改的， //因此无需实现save和delete方法 @Override public Mono&lt;Void&gt; save(Mono&lt;RouteDefinition&gt; mono) &#123; return mono.flatMap(r -&gt; &#123; try &#123; return Mono.empty(); &#125; catch (Exception e) &#123; e.printStackTrace(); return Mono.defer(() -&gt; Mono.error(new NotFoundException("RouteDefinition save error: "+ r.getId()))); &#125; &#125;); &#125; @Override public Mono&lt;Void&gt; delete(Mono&lt;String&gt; mono) &#123; return null; &#125;&#125; 自定义的路由信息类如下，仅供参考，可自行实现 123456789101112131415161718192021222324252627public class SysZuulRoute implements Serializable &#123; /** * 路由匹配路径 */ private String path; /** * 服务id */ private String serviceId; /** * 静态路由转发地址 */ private String url; /** * 转发去掉前缀 */ private String stripPrefix; /** * 是否启用 */ private String enabled; &#125; 这样就能实现路由的动态配置了。 备注本人使用的spring cloud gateway版本为2.1.0.RC3，其他版本可能会有细微区别]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>spring cloud gateway</tag>
        <tag>后台</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一个博客]]></title>
    <url>%2F2019%2F07%2F03%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[123function sayHello()&#123; console.lgo("hello world");&#125;]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
